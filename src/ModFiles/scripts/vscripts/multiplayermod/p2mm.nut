//----------------------------------------------------------------------------------//
//                                  COPYRIGHT                                       //
//                      Â© 2022 Portal 2: Multiplayer Mod                            //
//  https://github.com/Portal-2-Multiplayer-Mod/Portal-2-Multiplayer-Mod/LICENSE    //
//  In the case that this file does not exist at all or in the GitHub repository,   //
//      this project will fall under a GNU LESSER GENERAL PUBLIC LICENSE            //
//----------------------------------------------------------------------------------//

//---------------------------------------------------
//         *****!Do not edit this file!*****
//---------------------------------------------------
// Purpose: The heart of the mod's content. Runs on
// every map transition to bring about features and
//                 fixes for 3+ MP.
//---------------------------------------------------

// Stop the client VM from running this script.
if (!("Entities" in this)) { return }

printl("\n---------------------")
printl("==== calling p2mm.nut")
printl("---------------------\n")

// iCurGameIndex constants.
const PORTAL_2           = 0
const PORTAL_STORIES_MEL = 1
const APERTURE_TAG       = 2
const PORTAL_RELOADED    = 3
const INFRA              = 4
const DIVINITY           = 5

IncludeScript("multiplayermod/config.nut") // Import the user configuration and preferences and make sure nothing is invalid and compensate if so.
IncludeScript("multiplayermod/vars&funcs.nut") // Load global variables and functions.

// Bad way to check, but what else can we do?
if (Entities.FindByName(null, "p2mm_servercommand")){
    // Primary check in case the script attempts to execute midgame and it already has
    printlP2MM(1, false, "p2mm.nut is attempting to run again! Stopping!")
    return
} else {
    // Create a global point_servercommand entity for us to pass through commands
    Entities.CreateByClassname("point_servercommand").__KeyValueFromString("targetname", "p2mm_servercommand")
    Entities.CreateByClassname("point_clientcommand").__KeyValueFromString("targetname", "p2mm_clientcommand")
}

printlP2MM(0, true, "Session info...")
printlP2MM(0, true, "- Current map: " + GetMapName())
printlP2MM(0, true, "- Max players allowed on the server: " + GetMaxPlayers())
printlP2MM(0, true, "- Dedicated server: " + IsDedicatedServer())
printl("")

printlP2MM(0, true, "FirstRunState(-1): " + FirstRunState(-1).tostring())
printlP2MM(0, true, "GetLastMap(): " + GetLastMap())
printlP2MM(0, true, "GetMapName(): " + GetMapName())

// Check if its the first map run so Last Map System stuff can be done
if (FirstRunState(-1)) {
    FirstRunState(0) // Set that first run state to false

    // Reset developer level, developer needs to stay enabled for VScript Debugging to work
    if (Config_DevMode || Config_VScriptDebug) {
        EntFire("p2mm_servercommand", "command", "developer 1")
    }
    else {
        EntFire("p2mm_servercommand", "command", "developer 0")
    }
    
    // Check if Last Map System supplied a value and that it's a valid map, then restart on that map
    if (IsMapValid(GetLastMap()) && (GetLastMap() != GetMapName())) {
        FirstRunState(1) // Set state back to true because we are using one map as a transition to the map we actually want to be our first map

        printlP2MM(0, true, "Transitioning to Last/Singleplayer Map!")
        printlP2MM(0, true, "FirstRunState(-1): " + FirstRunState(-1).tostring())
        printlP2MM(0, true, "GetLastMap(): " + GetLastMap())
        printlP2MM(0, true, "GetMapName(): " + GetMapName())

        EntFire("p2mm_servercommand", "command", "changelevel " + GetLastMap(), 0.5)
        return
    }
}

// Prints the current map, needed for the Last Map System
// \n was here :>
printlP2MM(0, false, "MAP LOADED: " + GetMapName())

//-------------------------------------------------------------------------------------------

// Continue loading the P2:MM fixes, game mode, and features
IncludeScript("multiplayermod/safeguard.nut")
IncludeScript("multiplayermod/hooks.nut")
IncludeScript("multiplayermod/chatcommands.nut")

// Always have global root functions imported for any level
IncludeScript("multiplayermod/mapsupport/#propcreation.nut")
IncludeScript("multiplayermod/mapsupport/#rootfunctions.nut")

//---------------------------------------------------

// Print P2:MM game art in console
ConsoleAscii <- [
"########...#######...##..##.....##.##.....##",
"##.....##.##.....##.####.###...###.###...###",
"##.....##........##..##..####.####.####.####",
"########...#######.......##.###.##.##.###.##",
"##........##.........##..##.....##.##.....##",
"##........##........####.##.....##.##.....##",
"##........#########..##..##.....##.##.....##",
"                VERSION 2.3.0               "
]
printl("")
foreach (line in ConsoleAscii) { printl(line) }
delete ConsoleAscii
printl("")

//---------------------------------------------------

// Import map support code
// If the g_iCurGameIndex is invalid. nothing will load.
// Can't use the consts here as consts are compiled into the file and the file with them are only included later at runtime.
function LoadMapSupportCode(gametype) {
    printlP2MM(0, false, "=============================================================")
    switch (g_iCurGameIndex) {
        case (PORTAL_2):           printlP2MM(0, false, "Loading Portal 2 map support code..."); break;
        case (PORTAL_STORIES_MEL): printlP2MM(0, false, "Loading Portal Stories: Mel map support code..."); break;
        case (APERTURE_TAG):       printlP2MM(0, false, "Loading Aperture Tag map support code..."); break;
        case (PORTAL_RELOADED):    printlP2MM(0, false, "Loading Portal Reloaded map support code..."); break;
        case (INFRA):              printlP2MM(0, false, "Loading Infra map support code..."); break;
        case (DIVINITY):           printlP2MM(0, false, "Loading Portal: Divinity map support code..."); break;
        default:
            printlP2MM(1, false, "Invalid g_iCurGameIndex value! P2:MM has been loaded with a unsupported game/mod! Nothing will be loaded, issues might occur!")
            printlP2MM(0, false, "=============================================================\n")
            return
    }

    try {
        switch (g_iCurGameIndex) {
            case (PORTAL_2): IncludeScript("multiplayermod/mapsupport/portal2/" + GetMapName() + ".nut"); break;
            case (PORTAL_STORIES_MEL): IncludeScript("multiplayermod/mapsupport/portal_stories/" + GetMapName() + ".nut"); break;
            case (APERTURE_TAG): IncludeScript("multiplayermod/mapsupport/aperturetag/" + GetMapName() + ".nut"); break;
            case (PORTAL_RELOADED): IncludeScript("multiplayermod/mapsupport/portalreloaded/" + GetMapName() + ".nut"); break;
            case (INFRA): IncludeScript("multiplayermod/mapsupport/infra/" + GetMapName() + ".nut"); break;
            case (DIVINITY): IncludeScript("multiplayermod/mapsupport/divinity/" + GetMapName() + ".nut"); break;
        }
    } catch (exception) {
        // For mel, there are the advanced (sp_) and story (st_) maps.
        // Map supports were made primarily for advanced mode, but if a story map is loaded, it needs to fallback to the advanced mode map support.
        if (g_iCurGameIndex == PORTAL_STORIES_MEL) {
            printlP2MM(0, false, "Failed to load map for Portal Stories: Mel! Story map was possibly loaded, loading advanced mode map support \"multiplayermod/mapsupport/portal_stories/sp" + GetMapName().slice(2) + ".nut\"...")
            try {
                IncludeScript("multiplayermod/mapsupport/portal_stories/sp" + GetMapName().slice(2) + ".nut")
                printlP2MM(0, false, "Map support loaded successfully!")
                printlP2MM(0, false, "=============================================================\n")
                return
            } catch (exception) {}
        }
        printlP2MM(1, false, "Failed to load or no map support to load for \"" + GetMapName() + "\"")
        printlP2MM(1, true, "Exception: " + exception)
        printlP2MM(0, false, "=============================================================\n")
        return
    }
    printlP2MM(0, false, "Map support loaded successfully!")
    printlP2MM(0, false, "=============================================================\n")
}

// Now, manage everything the player has set in config.nut
// If the gamemode has exceptions of any kind, it will revert to standard Portal 2 mapsupport
printlP2MM(0, true, "GetGameMainDir(): " + GetGameMainDir())
printlP2MM(0, true, "GetGameRootDir(): " + GetGameRootDir())
LoadMapSupportCode(g_iCurGameIndex)

//---------------------------------------------------

// Run InstantRun() shortly AFTER spawn (hooks.nut)
EntFire("p2mm_servercommand", "command", "script InstantRun()", 0.02)
